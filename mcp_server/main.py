# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T11:44:28+00:00



import argparse
import json
import os
from typing import *
from typing import Optional, Union

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import APIKeyHeader, BaseSecurity
from fastapi import Header, Path, Query

from models import (
    AssociateRoleToGroupResponse,
    AssociateServiceRoleToAccountResponse,
    BadRequestException,
    CreateConnectorDefinitionResponse,
    CreateConnectorDefinitionVersionResponse,
    CreateCoreDefinitionResponse,
    CreateCoreDefinitionVersionResponse,
    CreateDeploymentResponse,
    CreateDeviceDefinitionResponse,
    CreateDeviceDefinitionVersionResponse,
    CreateFunctionDefinitionResponse,
    CreateFunctionDefinitionVersionResponse,
    CreateGroupCertificateAuthorityResponse,
    CreateGroupResponse,
    CreateGroupVersionResponse,
    CreateLoggerDefinitionResponse,
    CreateLoggerDefinitionVersionResponse,
    CreateResourceDefinitionResponse,
    CreateResourceDefinitionVersionResponse,
    CreateSoftwareUpdateJobResponse,
    CreateSubscriptionDefinitionResponse,
    CreateSubscriptionDefinitionVersionResponse,
    DeleteConnectorDefinitionResponse,
    DeleteCoreDefinitionResponse,
    DeleteDeviceDefinitionResponse,
    DeleteFunctionDefinitionResponse,
    DeleteGroupResponse,
    DeleteLoggerDefinitionResponse,
    DeleteResourceDefinitionResponse,
    DeleteSubscriptionDefinitionResponse,
    DisassociateRoleFromGroupResponse,
    DisassociateServiceRoleFromAccountResponse,
    GetAssociatedRoleResponse,
    GetBulkDeploymentStatusResponse,
    GetConnectivityInfoResponse,
    GetConnectorDefinitionResponse,
    GetConnectorDefinitionVersionResponse,
    GetCoreDefinitionResponse,
    GetCoreDefinitionVersionResponse,
    GetDeploymentStatusResponse,
    GetDeviceDefinitionResponse,
    GetDeviceDefinitionVersionResponse,
    GetFunctionDefinitionResponse,
    GetFunctionDefinitionVersionResponse,
    GetGroupCertificateAuthorityResponse,
    GetGroupCertificateConfigurationResponse,
    GetGroupResponse,
    GetGroupVersionResponse,
    GetLoggerDefinitionResponse,
    GetLoggerDefinitionVersionResponse,
    GetResourceDefinitionResponse,
    GetResourceDefinitionVersionResponse,
    GetServiceRoleForAccountResponse,
    GetSubscriptionDefinitionResponse,
    GetSubscriptionDefinitionVersionResponse,
    GetThingRuntimeConfigurationResponse,
    GreengrassBulkDeploymentsPostRequest,
    GreengrassDefinitionConnectorsConnectorDefinitionIdPutRequest,
    GreengrassDefinitionConnectorsConnectorDefinitionIdVersionsPostRequest,
    GreengrassDefinitionConnectorsPostRequest,
    GreengrassDefinitionCoresCoreDefinitionIdPutRequest,
    GreengrassDefinitionCoresCoreDefinitionIdVersionsPostRequest,
    GreengrassDefinitionCoresPostRequest,
    GreengrassDefinitionDevicesDeviceDefinitionIdPutRequest,
    GreengrassDefinitionDevicesDeviceDefinitionIdVersionsPostRequest,
    GreengrassDefinitionDevicesPostRequest,
    GreengrassDefinitionFunctionsFunctionDefinitionIdPutRequest,
    GreengrassDefinitionFunctionsFunctionDefinitionIdVersionsPostRequest,
    GreengrassDefinitionFunctionsPostRequest,
    GreengrassDefinitionLoggersLoggerDefinitionIdPutRequest,
    GreengrassDefinitionLoggersLoggerDefinitionIdVersionsPostRequest,
    GreengrassDefinitionLoggersPostRequest,
    GreengrassDefinitionResourcesPostRequest,
    GreengrassDefinitionResourcesResourceDefinitionIdPutRequest,
    GreengrassDefinitionResourcesResourceDefinitionIdVersionsPostRequest,
    GreengrassDefinitionSubscriptionsPostRequest,
    GreengrassDefinitionSubscriptionsSubscriptionDefinitionIdPutRequest,
    GreengrassDefinitionSubscriptionsSubscriptionDefinitionIdVersionsPostRequest,
    GreengrassGroupsGroupIdCertificateauthoritiesConfigurationExpiryPutRequest,
    GreengrassGroupsGroupIdDeploymentsPostRequest,
    GreengrassGroupsGroupIdDeploymentsResetPostRequest,
    GreengrassGroupsGroupIdPutRequest,
    GreengrassGroupsGroupIdRolePutRequest,
    GreengrassGroupsGroupIdVersionsPostRequest,
    GreengrassGroupsPostRequest,
    GreengrassServicerolePutRequest,
    GreengrassThingsThingNameConnectivityInfoPutRequest,
    GreengrassThingsThingNameRuntimeconfigPutRequest,
    GreengrassUpdatesPostRequest,
    InternalServerErrorException,
    ListBulkDeploymentDetailedReportsResponse,
    ListBulkDeploymentsResponse,
    ListConnectorDefinitionsResponse,
    ListConnectorDefinitionVersionsResponse,
    ListCoreDefinitionsResponse,
    ListCoreDefinitionVersionsResponse,
    ListDeploymentsResponse,
    ListDeviceDefinitionsResponse,
    ListDeviceDefinitionVersionsResponse,
    ListFunctionDefinitionsResponse,
    ListFunctionDefinitionVersionsResponse,
    ListGroupCertificateAuthoritiesResponse,
    ListGroupsResponse,
    ListGroupVersionsResponse,
    ListLoggerDefinitionsResponse,
    ListLoggerDefinitionVersionsResponse,
    ListResourceDefinitionsResponse,
    ListResourceDefinitionVersionsResponse,
    ListSubscriptionDefinitionsResponse,
    ListSubscriptionDefinitionVersionsResponse,
    ListTagsForResourceResponse,
    ResetDeploymentsResponse,
    StartBulkDeploymentResponse,
    StopBulkDeploymentResponse,
    TagKeys,
    TagsResourceArnPostRequest,
    UpdateConnectivityInfoResponse,
    UpdateConnectorDefinitionResponse,
    UpdateCoreDefinitionResponse,
    UpdateDeviceDefinitionResponse,
    UpdateFunctionDefinitionResponse,
    UpdateGroupCertificateConfigurationResponse,
    UpdateGroupResponse,
    UpdateLoggerDefinitionResponse,
    UpdateResourceDefinitionResponse,
    UpdateSubscriptionDefinitionResponse,
    UpdateThingRuntimeConfigurationResponse,
)

app = MCPProxy(
    contact={
        'email': 'mike.ralphson@gmail.com',
        'name': 'Mike Ralphson',
        'url': 'https://github.com/mermade/aws2openapi',
        'x-twitter': 'PermittedSoc',
    },
    description='AWS IoT Greengrass seamlessly extends AWS onto physical devices so they can act locally on the data they generate, while still using the cloud for management, analytics, and durable storage. AWS IoT Greengrass ensures your devices can respond quickly to local events and operate with intermittent connectivity. AWS IoT Greengrass minimizes the cost of transmitting data to the cloud by allowing you to author AWS Lambda functions that execute locally.',
    license={'name': 'Apache 2.0 License', 'url': 'http://www.apache.org/licenses/'},
    termsOfService='https://aws.amazon.com/service-terms/',
    title='AWS Greengrass',
    version='2017-06-07',
    servers=[
        {
            'description': 'The AWS Greengrass multi-region endpoint',
            'url': 'http://greengrass.{region}.amazonaws.com',
            'variables': {
                'region': {
                    'default': 'us-east-1',
                    'description': 'The AWS region',
                    'enum': [
                        'us-east-1',
                        'us-east-2',
                        'us-west-1',
                        'us-west-2',
                        'us-gov-west-1',
                        'us-gov-east-1',
                        'ca-central-1',
                        'eu-north-1',
                        'eu-west-1',
                        'eu-west-2',
                        'eu-west-3',
                        'eu-central-1',
                        'eu-south-1',
                        'af-south-1',
                        'ap-northeast-1',
                        'ap-northeast-2',
                        'ap-northeast-3',
                        'ap-southeast-1',
                        'ap-southeast-2',
                        'ap-east-1',
                        'ap-south-1',
                        'sa-east-1',
                        'me-south-1',
                    ],
                }
            },
        },
        {
            'description': 'The AWS Greengrass multi-region endpoint',
            'url': 'https://greengrass.{region}.amazonaws.com',
            'variables': {
                'region': {
                    'default': 'us-east-1',
                    'description': 'The AWS region',
                    'enum': [
                        'us-east-1',
                        'us-east-2',
                        'us-west-1',
                        'us-west-2',
                        'us-gov-west-1',
                        'us-gov-east-1',
                        'ca-central-1',
                        'eu-north-1',
                        'eu-west-1',
                        'eu-west-2',
                        'eu-west-3',
                        'eu-central-1',
                        'eu-south-1',
                        'af-south-1',
                        'ap-northeast-1',
                        'ap-northeast-2',
                        'ap-northeast-3',
                        'ap-southeast-1',
                        'ap-southeast-2',
                        'ap-east-1',
                        'ap-south-1',
                        'sa-east-1',
                        'me-south-1',
                    ],
                }
            },
        },
        {
            'description': 'The AWS Greengrass endpoint for China (Beijing) and China (Ningxia)',
            'url': 'http://greengrass.{region}.amazonaws.com.cn',
            'variables': {
                'region': {
                    'default': 'cn-north-1',
                    'description': 'The AWS region',
                    'enum': ['cn-north-1', 'cn-northwest-1'],
                }
            },
        },
        {
            'description': 'The AWS Greengrass endpoint for China (Beijing) and China (Ningxia)',
            'url': 'https://greengrass.{region}.amazonaws.com.cn',
            'variables': {
                'region': {
                    'default': 'cn-north-1',
                    'description': 'The AWS region',
                    'enum': ['cn-north-1', 'cn-northwest-1'],
                }
            },
        },
    ],
)


@app.get(
    '/greengrass/bulk/deployments',
    description=""" Returns a list of bulk deployments. """,
    tags=['resource_definition_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_bulk_deployments(
    max_results: Optional[str] = Query(None, alias='MaxResults'),
    next_token: Optional[str] = Query(None, alias='NextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/greengrass/bulk/deployments',
    description=""" Deploys multiple groups in one operation. This action starts the bulk deployment of a specified set of group versions. Each group version deployment will be triggered with an adaptive rate that has a fixed upper limit. We recommend that you include an ''X-Amzn-Client-Token'' token in every ''StartBulkDeployment'' request. These requests are idempotent with respect to the token and the request parameters. """,
    tags=['bulk_deployment_operations', 'deployment_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def start_bulk_deployment(
    x__amzn__client__token: Optional[str] = Header(None, alias='X-Amzn-Client-Token'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: GreengrassBulkDeploymentsPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/greengrass/bulk/deployments/{BulkDeploymentId}/$stop',
    description=""" Stops the execution of a bulk deployment. This action returns a status of ''Stopping'' until the deployment is stopped. You cannot start a new bulk deployment while a previous deployment is in the ''Stopping'' state. This action doesn't rollback completed deployments or cancel pending deployments. """,
    tags=['bulk_deployment_operations', 'deployment_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def stop_bulk_deployment(
    bulk_deployment_id: str = Path(..., alias='BulkDeploymentId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/greengrass/bulk/deployments/{BulkDeploymentId}/detailed-reports',
    description=""" Gets a paginated list of the deployments that have been started in a bulk deployment operation, and their current deployment status. """,
    tags=['bulk_deployment_operations', 'deployment_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_bulk_deployment_detailed_reports(
    bulk_deployment_id: str = Path(..., alias='BulkDeploymentId'),
    max_results: Optional[str] = Query(None, alias='MaxResults'),
    next_token: Optional[str] = Query(None, alias='NextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/greengrass/bulk/deployments/{BulkDeploymentId}/status',
    description=""" Returns the status of a bulk deployment. """,
    tags=['bulk_deployment_operations', 'deployment_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_bulk_deployment_status(
    bulk_deployment_id: str = Path(..., alias='BulkDeploymentId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/greengrass/definition/connectors',
    description=""" Retrieves a list of connector definitions. """,
    tags=['service_role_configuration'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_connector_definitions(
    max_results: Optional[str] = Query(None, alias='MaxResults'),
    next_token: Optional[str] = Query(None, alias='NextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/greengrass/definition/connectors',
    description=""" Creates a connector definition. You may provide the initial version of the connector definition now or use ''CreateConnectorDefinitionVersion'' at a later time. """,
    tags=['iot_device_connectivity'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_connector_definition(
    x__amzn__client__token: Optional[str] = Header(None, alias='X-Amzn-Client-Token'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: GreengrassDefinitionConnectorsPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/greengrass/definition/connectors/{ConnectorDefinitionId}',
    description=""" Deletes a connector definition. """,
    tags=['connector_version_control'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_connector_definition(
    connector_definition_id: str = Path(..., alias='ConnectorDefinitionId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/greengrass/definition/connectors/{ConnectorDefinitionId}',
    description=""" Retrieves information about a connector definition. """,
    tags=['connector_version_control'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_connector_definition(
    connector_definition_id: str = Path(..., alias='ConnectorDefinitionId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/greengrass/definition/connectors/{ConnectorDefinitionId}',
    description=""" Updates a connector definition. """,
    tags=['connector_version_control'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_connector_definition(
    connector_definition_id: str = Path(..., alias='ConnectorDefinitionId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: GreengrassDefinitionConnectorsConnectorDefinitionIdPutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/greengrass/definition/connectors/{ConnectorDefinitionId}/versions',
    description=""" Lists the versions of a connector definition, which are containers for connectors. Connectors run on the Greengrass core and contain built-in integration with local infrastructure, device protocols, AWS, and other cloud services. """,
    tags=['connector_version_control'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_connector_definition_versions(
    connector_definition_id: str = Path(..., alias='ConnectorDefinitionId'),
    max_results: Optional[str] = Query(None, alias='MaxResults'),
    next_token: Optional[str] = Query(None, alias='NextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/greengrass/definition/connectors/{ConnectorDefinitionId}/versions',
    description=""" Creates a version of a connector definition which has already been defined. """,
    tags=['connector_version_control'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_connector_definition_version(
    x__amzn__client__token: Optional[str] = Header(None, alias='X-Amzn-Client-Token'),
    connector_definition_id: str = Path(..., alias='ConnectorDefinitionId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: GreengrassDefinitionConnectorsConnectorDefinitionIdVersionsPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/greengrass/definition/connectors/{ConnectorDefinitionId}/versions/{ConnectorDefinitionVersionId}',
    description=""" Retrieves information about a connector definition version, including the connectors that the version contains. Connectors are prebuilt modules that interact with local infrastructure, device protocols, AWS, and other cloud services. """,
    tags=['connector_version_control'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_connector_definition_version(
    connector_definition_id: str = Path(..., alias='ConnectorDefinitionId'),
    connector_definition_version_id: str = Path(
        ..., alias='ConnectorDefinitionVersionId'
    ),
    next_token: Optional[str] = Query(None, alias='NextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/greengrass/definition/cores',
    description=""" Retrieves a list of core definitions. """,
    tags=[
        'bulk_deployment_operations',
        'deployment_operations',
        'service_role_configuration',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_core_definitions(
    max_results: Optional[str] = Query(None, alias='MaxResults'),
    next_token: Optional[str] = Query(None, alias='NextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/greengrass/definition/cores',
    description=""" Creates a core definition. You may provide the initial version of the core definition now or use ''CreateCoreDefinitionVersion'' at a later time. Greengrass groups must each contain exactly one Greengrass core. """,
    tags=[
        'core_definition_handling',
        'deployment_operations',
        'iot_device_connectivity',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_core_definition(
    x__amzn__client__token: Optional[str] = Header(None, alias='X-Amzn-Client-Token'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: GreengrassDefinitionCoresPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/greengrass/definition/cores/{CoreDefinitionId}',
    description=""" Deletes a core definition. """,
    tags=['core_definition_handling', 'connector_version_control'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_core_definition(
    core_definition_id: str = Path(..., alias='CoreDefinitionId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/greengrass/definition/cores/{CoreDefinitionId}',
    description=""" Retrieves information about a core definition version. """,
    tags=['core_definition_handling', 'function_version_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_core_definition(
    core_definition_id: str = Path(..., alias='CoreDefinitionId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/greengrass/definition/cores/{CoreDefinitionId}',
    description=""" Updates a core definition. """,
    tags=['core_definition_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_core_definition(
    core_definition_id: str = Path(..., alias='CoreDefinitionId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: GreengrassDefinitionCoresCoreDefinitionIdPutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/greengrass/definition/cores/{CoreDefinitionId}/versions',
    description=""" Lists the versions of a core definition. """,
    tags=['core_definition_handling', 'connector_version_control'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_core_definition_versions(
    core_definition_id: str = Path(..., alias='CoreDefinitionId'),
    max_results: Optional[str] = Query(None, alias='MaxResults'),
    next_token: Optional[str] = Query(None, alias='NextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/greengrass/definition/cores/{CoreDefinitionId}/versions',
    description=""" Creates a version of a core definition that has already been defined. Greengrass groups must each contain exactly one Greengrass core. """,
    tags=['core_definition_handling', 'function_version_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_core_definition_version(
    x__amzn__client__token: Optional[str] = Header(None, alias='X-Amzn-Client-Token'),
    core_definition_id: str = Path(..., alias='CoreDefinitionId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: GreengrassDefinitionCoresCoreDefinitionIdVersionsPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/greengrass/definition/cores/{CoreDefinitionId}/versions/{CoreDefinitionVersionId}',
    description=""" Retrieves information about a core definition version. """,
    tags=[
        'core_definition_handling',
        'function_version_operations',
        'connector_version_control',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_core_definition_version(
    core_definition_id: str = Path(..., alias='CoreDefinitionId'),
    core_definition_version_id: str = Path(..., alias='CoreDefinitionVersionId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/greengrass/definition/devices',
    description=""" Retrieves a list of device definitions. """,
    tags=['deployment_operations', 'service_role_configuration'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_device_definitions(
    max_results: Optional[str] = Query(None, alias='MaxResults'),
    next_token: Optional[str] = Query(None, alias='NextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/greengrass/definition/devices',
    description=""" Creates a device definition. You may provide the initial version of the device definition now or use ''CreateDeviceDefinitionVersion'' at a later time. """,
    tags=['iot_device_connectivity'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_device_definition(
    x__amzn__client__token: Optional[str] = Header(None, alias='X-Amzn-Client-Token'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: GreengrassDefinitionDevicesPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/greengrass/definition/devices/{DeviceDefinitionId}',
    description=""" Deletes a device definition. """,
    tags=['device_version_management', 'iot_device_connectivity'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_device_definition(
    device_definition_id: str = Path(..., alias='DeviceDefinitionId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/greengrass/definition/devices/{DeviceDefinitionId}',
    description=""" Retrieves information about a device definition. """,
    tags=['device_version_management', 'iot_device_connectivity'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_device_definition(
    device_definition_id: str = Path(..., alias='DeviceDefinitionId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/greengrass/definition/devices/{DeviceDefinitionId}',
    description=""" Updates a device definition. """,
    tags=['device_version_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_device_definition(
    device_definition_id: str = Path(..., alias='DeviceDefinitionId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: GreengrassDefinitionDevicesDeviceDefinitionIdPutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/greengrass/definition/devices/{DeviceDefinitionId}/versions',
    description=""" Lists the versions of a device definition. """,
    tags=['device_version_management', 'iot_device_connectivity'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_device_definition_versions(
    device_definition_id: str = Path(..., alias='DeviceDefinitionId'),
    max_results: Optional[str] = Query(None, alias='MaxResults'),
    next_token: Optional[str] = Query(None, alias='NextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/greengrass/definition/devices/{DeviceDefinitionId}/versions',
    description=""" Creates a version of a device definition that has already been defined. """,
    tags=['device_version_management', 'iot_device_connectivity'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_device_definition_version(
    x__amzn__client__token: Optional[str] = Header(None, alias='X-Amzn-Client-Token'),
    device_definition_id: str = Path(..., alias='DeviceDefinitionId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: GreengrassDefinitionDevicesDeviceDefinitionIdVersionsPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/greengrass/definition/devices/{DeviceDefinitionId}/versions/{DeviceDefinitionVersionId}',
    description=""" Retrieves information about a device definition version. """,
    tags=['device_version_management', 'iot_device_connectivity'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_device_definition_version(
    device_definition_id: str = Path(..., alias='DeviceDefinitionId'),
    device_definition_version_id: str = Path(..., alias='DeviceDefinitionVersionId'),
    next_token: Optional[str] = Query(None, alias='NextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/greengrass/definition/functions',
    description=""" Retrieves a list of Lambda function definitions. """,
    tags=['deployment_operations', 'service_role_configuration'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_function_definitions(
    max_results: Optional[str] = Query(None, alias='MaxResults'),
    next_token: Optional[str] = Query(None, alias='NextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/greengrass/definition/functions',
    description=""" Creates a Lambda function definition which contains a list of Lambda functions and their configurations to be used in a group. You can create an initial version of the definition by providing a list of Lambda functions and their configurations now, or use ''CreateFunctionDefinitionVersion'' later. """,
    tags=['function_version_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_function_definition(
    x__amzn__client__token: Optional[str] = Header(None, alias='X-Amzn-Client-Token'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: GreengrassDefinitionFunctionsPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/greengrass/definition/functions/{FunctionDefinitionId}',
    description=""" Deletes a Lambda function definition. """,
    tags=['function_version_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_function_definition(
    function_definition_id: str = Path(..., alias='FunctionDefinitionId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/greengrass/definition/functions/{FunctionDefinitionId}',
    description=""" Retrieves information about a Lambda function definition, including its creation time and latest version. """,
    tags=['function_version_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_function_definition(
    function_definition_id: str = Path(..., alias='FunctionDefinitionId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/greengrass/definition/functions/{FunctionDefinitionId}',
    description=""" Updates a Lambda function definition. """,
    tags=['function_version_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_function_definition(
    function_definition_id: str = Path(..., alias='FunctionDefinitionId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: GreengrassDefinitionFunctionsFunctionDefinitionIdPutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/greengrass/definition/functions/{FunctionDefinitionId}/versions',
    description=""" Lists the versions of a Lambda function definition. """,
    tags=['function_version_operations', 'core_definition_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_function_definition_versions(
    function_definition_id: str = Path(..., alias='FunctionDefinitionId'),
    max_results: Optional[str] = Query(None, alias='MaxResults'),
    next_token: Optional[str] = Query(None, alias='NextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/greengrass/definition/functions/{FunctionDefinitionId}/versions',
    description=""" Creates a version of a Lambda function definition that has already been defined. """,
    tags=['function_version_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_function_definition_version(
    x__amzn__client__token: Optional[str] = Header(None, alias='X-Amzn-Client-Token'),
    function_definition_id: str = Path(..., alias='FunctionDefinitionId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: GreengrassDefinitionFunctionsFunctionDefinitionIdVersionsPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/greengrass/definition/functions/{FunctionDefinitionId}/versions/{FunctionDefinitionVersionId}',
    description=""" Retrieves information about a Lambda function definition version, including which Lambda functions are included in the version and their configurations. """,
    tags=['function_version_operations', 'core_definition_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_function_definition_version(
    function_definition_id: str = Path(..., alias='FunctionDefinitionId'),
    function_definition_version_id: str = Path(
        ..., alias='FunctionDefinitionVersionId'
    ),
    next_token: Optional[str] = Query(None, alias='NextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/greengrass/definition/loggers',
    description=""" Retrieves a list of logger definitions. """,
    tags=['core_definition_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_logger_definitions(
    max_results: Optional[str] = Query(None, alias='MaxResults'),
    next_token: Optional[str] = Query(None, alias='NextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/greengrass/definition/loggers',
    description=""" Creates a logger definition. You may provide the initial version of the logger definition now or use ''CreateLoggerDefinitionVersion'' at a later time. """,
    tags=['logger_version_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_logger_definition(
    x__amzn__client__token: Optional[str] = Header(None, alias='X-Amzn-Client-Token'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: GreengrassDefinitionLoggersPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/greengrass/definition/loggers/{LoggerDefinitionId}',
    description=""" Deletes a logger definition. """,
    tags=['logger_version_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_logger_definition(
    logger_definition_id: str = Path(..., alias='LoggerDefinitionId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/greengrass/definition/loggers/{LoggerDefinitionId}',
    description=""" Retrieves information about a logger definition. """,
    tags=['logger_version_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_logger_definition(
    logger_definition_id: str = Path(..., alias='LoggerDefinitionId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/greengrass/definition/loggers/{LoggerDefinitionId}',
    description=""" Updates a logger definition. """,
    tags=['logger_version_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_logger_definition(
    logger_definition_id: str = Path(..., alias='LoggerDefinitionId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: GreengrassDefinitionLoggersLoggerDefinitionIdPutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/greengrass/definition/loggers/{LoggerDefinitionId}/versions',
    description=""" Lists the versions of a logger definition. """,
    tags=['logger_version_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_logger_definition_versions(
    logger_definition_id: str = Path(..., alias='LoggerDefinitionId'),
    max_results: Optional[str] = Query(None, alias='MaxResults'),
    next_token: Optional[str] = Query(None, alias='NextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/greengrass/definition/loggers/{LoggerDefinitionId}/versions',
    description=""" Creates a version of a logger definition that has already been defined. """,
    tags=['logger_version_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_logger_definition_version(
    x__amzn__client__token: Optional[str] = Header(None, alias='X-Amzn-Client-Token'),
    logger_definition_id: str = Path(..., alias='LoggerDefinitionId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: GreengrassDefinitionLoggersLoggerDefinitionIdVersionsPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/greengrass/definition/loggers/{LoggerDefinitionId}/versions/{LoggerDefinitionVersionId}',
    description=""" Retrieves information about a logger definition version. """,
    tags=['logger_version_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_logger_definition_version(
    logger_definition_id: str = Path(..., alias='LoggerDefinitionId'),
    logger_definition_version_id: str = Path(..., alias='LoggerDefinitionVersionId'),
    next_token: Optional[str] = Query(None, alias='NextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/greengrass/definition/resources',
    description=""" Retrieves a list of resource definitions. """,
    tags=['service_role_configuration', 'iot_device_connectivity'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_resource_definitions(
    max_results: Optional[str] = Query(None, alias='MaxResults'),
    next_token: Optional[str] = Query(None, alias='NextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/greengrass/definition/resources',
    description=""" Creates a resource definition which contains a list of resources to be used in a group. You can create an initial version of the definition by providing a list of resources now, or use ''CreateResourceDefinitionVersion'' later. """,
    tags=['iot_device_connectivity'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_resource_definition(
    x__amzn__client__token: Optional[str] = Header(None, alias='X-Amzn-Client-Token'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: GreengrassDefinitionResourcesPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/greengrass/definition/resources/{ResourceDefinitionId}',
    description=""" Deletes a resource definition. """,
    tags=['resource_definition_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_resource_definition(
    resource_definition_id: str = Path(..., alias='ResourceDefinitionId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/greengrass/definition/resources/{ResourceDefinitionId}',
    description=""" Retrieves information about a resource definition, including its creation time and latest version. """,
    tags=['resource_definition_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_resource_definition(
    resource_definition_id: str = Path(..., alias='ResourceDefinitionId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/greengrass/definition/resources/{ResourceDefinitionId}',
    description=""" Updates a resource definition. """,
    tags=['resource_definition_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_resource_definition(
    resource_definition_id: str = Path(..., alias='ResourceDefinitionId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: GreengrassDefinitionResourcesResourceDefinitionIdPutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/greengrass/definition/resources/{ResourceDefinitionId}/versions',
    description=""" Lists the versions of a resource definition. """,
    tags=['resource_definition_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_resource_definition_versions(
    max_results: Optional[str] = Query(None, alias='MaxResults'),
    next_token: Optional[str] = Query(None, alias='NextToken'),
    resource_definition_id: str = Path(..., alias='ResourceDefinitionId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/greengrass/definition/resources/{ResourceDefinitionId}/versions',
    description=""" Creates a version of a resource definition that has already been defined. """,
    tags=['resource_definition_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_resource_definition_version(
    x__amzn__client__token: Optional[str] = Header(None, alias='X-Amzn-Client-Token'),
    resource_definition_id: str = Path(..., alias='ResourceDefinitionId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: GreengrassDefinitionResourcesResourceDefinitionIdVersionsPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/greengrass/definition/resources/{ResourceDefinitionId}/versions/{ResourceDefinitionVersionId}',
    description=""" Retrieves information about a resource definition version, including which resources are included in the version. """,
    tags=['resource_definition_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_resource_definition_version(
    resource_definition_id: str = Path(..., alias='ResourceDefinitionId'),
    resource_definition_version_id: str = Path(
        ..., alias='ResourceDefinitionVersionId'
    ),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/greengrass/definition/subscriptions',
    description=""" Retrieves a list of subscription definitions. """,
    tags=['function_version_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_subscription_definitions(
    max_results: Optional[str] = Query(None, alias='MaxResults'),
    next_token: Optional[str] = Query(None, alias='NextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/greengrass/definition/subscriptions',
    description=""" Creates a subscription definition. You may provide the initial version of the subscription definition now or use ''CreateSubscriptionDefinitionVersion'' at a later time. """,
    tags=['function_version_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_subscription_definition(
    x__amzn__client__token: Optional[str] = Header(None, alias='X-Amzn-Client-Token'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: GreengrassDefinitionSubscriptionsPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/greengrass/definition/subscriptions/{SubscriptionDefinitionId}',
    description=""" Deletes a subscription definition. """,
    tags=['subscription_version_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_subscription_definition(
    subscription_definition_id: str = Path(..., alias='SubscriptionDefinitionId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/greengrass/definition/subscriptions/{SubscriptionDefinitionId}',
    description=""" Retrieves information about a subscription definition. """,
    tags=['subscription_version_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_subscription_definition(
    subscription_definition_id: str = Path(..., alias='SubscriptionDefinitionId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/greengrass/definition/subscriptions/{SubscriptionDefinitionId}',
    description=""" Updates a subscription definition. """,
    tags=['subscription_version_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_subscription_definition(
    subscription_definition_id: str = Path(..., alias='SubscriptionDefinitionId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: GreengrassDefinitionSubscriptionsSubscriptionDefinitionIdPutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/greengrass/definition/subscriptions/{SubscriptionDefinitionId}/versions',
    description=""" Lists the versions of a subscription definition. """,
    tags=['subscription_version_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_subscription_definition_versions(
    max_results: Optional[str] = Query(None, alias='MaxResults'),
    next_token: Optional[str] = Query(None, alias='NextToken'),
    subscription_definition_id: str = Path(..., alias='SubscriptionDefinitionId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/greengrass/definition/subscriptions/{SubscriptionDefinitionId}/versions',
    description=""" Creates a version of a subscription definition which has already been defined. """,
    tags=['subscription_version_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_subscription_definition_version(
    x__amzn__client__token: Optional[str] = Header(None, alias='X-Amzn-Client-Token'),
    subscription_definition_id: str = Path(..., alias='SubscriptionDefinitionId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: GreengrassDefinitionSubscriptionsSubscriptionDefinitionIdVersionsPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/greengrass/definition/subscriptions/{SubscriptionDefinitionId}/versions/{SubscriptionDefinitionVersionId}',
    description=""" Retrieves information about a subscription definition version. """,
    tags=['subscription_version_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_subscription_definition_version(
    next_token: Optional[str] = Query(None, alias='NextToken'),
    subscription_definition_id: str = Path(..., alias='SubscriptionDefinitionId'),
    subscription_definition_version_id: str = Path(
        ..., alias='SubscriptionDefinitionVersionId'
    ),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/greengrass/groups',
    description=""" Retrieves a list of groups. """,
    tags=['service_role_configuration'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_groups(
    max_results: Optional[str] = Query(None, alias='MaxResults'),
    next_token: Optional[str] = Query(None, alias='NextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/greengrass/groups',
    description=""" Creates a group. You may provide the initial version of the group or use ''CreateGroupVersion'' at a later time. Tip: You can use the ''gg_group_setup'' package (https://github.com/awslabs/aws-greengrass-group-setup) as a library or command-line application to create and deploy Greengrass groups. """,
    tags=['group_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_group(
    x__amzn__client__token: Optional[str] = Header(None, alias='X-Amzn-Client-Token'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: GreengrassGroupsPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/greengrass/groups/{GroupId}',
    description=""" Deletes a group. """,
    tags=['group_operations', 'group_certificate_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def delete_group(
    group_id: str = Path(..., alias='GroupId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/greengrass/groups/{GroupId}',
    description=""" Retrieves information about a group. """,
    tags=['group_operations', 'group_certificate_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_group(
    group_id: str = Path(..., alias='GroupId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/greengrass/groups/{GroupId}',
    description=""" Updates a group. """,
    tags=['group_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_group(
    group_id: str = Path(..., alias='GroupId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: GreengrassGroupsGroupIdPutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/greengrass/groups/{GroupId}/certificateauthorities',
    description=""" Retrieves the current CAs for a group. """,
    tags=['group_operations', 'group_certificate_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_group_certificate_authorities(
    group_id: str = Path(..., alias='GroupId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/greengrass/groups/{GroupId}/certificateauthorities',
    description=""" Creates a CA for the group. If a CA already exists, it will rotate the existing CA. """,
    tags=['group_operations', 'group_certificate_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_group_certificate_authority(
    x__amzn__client__token: Optional[str] = Header(None, alias='X-Amzn-Client-Token'),
    group_id: str = Path(..., alias='GroupId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/greengrass/groups/{GroupId}/certificateauthorities/configuration/expiry',
    description=""" Retrieves the current configuration for the CA used by the group. """,
    tags=['group_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_group_certificate_configuration(
    group_id: str = Path(..., alias='GroupId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/greengrass/groups/{GroupId}/certificateauthorities/configuration/expiry',
    description=""" Updates the Certificate expiry time for a group. """,
    tags=['group_certificate_management', 'group_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_group_certificate_configuration(
    group_id: str = Path(..., alias='GroupId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: GreengrassGroupsGroupIdCertificateauthoritiesConfigurationExpiryPutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/greengrass/groups/{GroupId}/certificateauthorities/{CertificateAuthorityId}',
    description=""" Retreives the CA associated with a group. Returns the public key of the CA. """,
    tags=['group_operations', 'group_certificate_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_group_certificate_authority(
    certificate_authority_id: str = Path(..., alias='CertificateAuthorityId'),
    group_id: str = Path(..., alias='GroupId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/greengrass/groups/{GroupId}/deployments',
    description=""" Returns a history of deployments for the group. """,
    tags=['group_operations', 'deployment_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_deployments(
    group_id: str = Path(..., alias='GroupId'),
    max_results: Optional[str] = Query(None, alias='MaxResults'),
    next_token: Optional[str] = Query(None, alias='NextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/greengrass/groups/{GroupId}/deployments',
    description=""" Creates a deployment. ''CreateDeployment'' requests are idempotent with respect to the ''X-Amzn-Client-Token'' token and the request parameters. """,
    tags=['group_operations', 'deployment_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_deployment(
    x__amzn__client__token: Optional[str] = Header(None, alias='X-Amzn-Client-Token'),
    group_id: str = Path(..., alias='GroupId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: GreengrassGroupsGroupIdDeploymentsPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/greengrass/groups/{GroupId}/deployments/$reset',
    description=""" Resets a group's deployments. """,
    tags=['group_operations', 'deployment_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def reset_deployments(
    x__amzn__client__token: Optional[str] = Header(None, alias='X-Amzn-Client-Token'),
    group_id: str = Path(..., alias='GroupId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: GreengrassGroupsGroupIdDeploymentsResetPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/greengrass/groups/{GroupId}/deployments/{DeploymentId}/status',
    description=""" Returns the status of a deployment. """,
    tags=['deployment_operations', 'group_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_deployment_status(
    deployment_id: str = Path(..., alias='DeploymentId'),
    group_id: str = Path(..., alias='GroupId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/greengrass/groups/{GroupId}/role',
    description=""" Disassociates the role from a group. """,
    tags=['group_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def disassociate_role_from_group(
    group_id: str = Path(..., alias='GroupId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/greengrass/groups/{GroupId}/role',
    description=""" Retrieves the role associated with a particular group. """,
    tags=['group_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_associated_role(
    group_id: str = Path(..., alias='GroupId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/greengrass/groups/{GroupId}/role',
    description=""" Associates a role with a group. Your Greengrass core will use the role to access AWS cloud services. The role's permissions should allow Greengrass core Lambda functions to perform actions against the cloud. """,
    tags=['group_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def associate_role_to_group(
    group_id: str = Path(..., alias='GroupId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: GreengrassGroupsGroupIdRolePutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/greengrass/groups/{GroupId}/versions',
    description=""" Lists the versions of a group. """,
    tags=['group_operations'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_group_versions(
    group_id: str = Path(..., alias='GroupId'),
    max_results: Optional[str] = Query(None, alias='MaxResults'),
    next_token: Optional[str] = Query(None, alias='NextToken'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/greengrass/groups/{GroupId}/versions',
    description=""" Creates a version of a group which has already been defined. """,
    tags=['group_operations', 'resource_definition_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_group_version(
    x__amzn__client__token: Optional[str] = Header(None, alias='X-Amzn-Client-Token'),
    group_id: str = Path(..., alias='GroupId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: GreengrassGroupsGroupIdVersionsPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/greengrass/groups/{GroupId}/versions/{GroupVersionId}',
    description=""" Retrieves information about a group version. """,
    tags=[
        'group_operations',
        'connector_version_control',
        'function_version_operations',
    ],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_group_version(
    group_id: str = Path(..., alias='GroupId'),
    group_version_id: str = Path(..., alias='GroupVersionId'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/greengrass/servicerole',
    description=""" Disassociates the service role from your account. Without a service role, deployments will not work. """,
    tags=['iot_device_connectivity', 'service_role_configuration'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def disassociate_service_role_from_account(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/greengrass/servicerole',
    description=""" Retrieves the service role that is attached to your account. """,
    tags=['iot_device_connectivity'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_service_role_for_account(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/greengrass/servicerole',
    description=""" Associates a role with your account. AWS IoT Greengrass will use the role to access your Lambda functions and AWS IoT resources. This is necessary for deployments to succeed. The role must have at least minimum permissions in the policy ''AWSGreengrassResourceAccessRolePolicy''. """,
    tags=['service_role_configuration'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def associate_service_role_to_account(
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: GreengrassServicerolePutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/greengrass/things/{ThingName}/connectivityInfo',
    description=""" Retrieves the connectivity information for a core. """,
    tags=['service_role_configuration', 'iot_device_connectivity'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_connectivity_info(
    thing_name: str = Path(..., alias='ThingName'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/greengrass/things/{ThingName}/connectivityInfo',
    description=""" Updates the connectivity information for the core. Any devices that belong to the group which has this core will receive this information in order to find the location of the core and connect to it. """,
    tags=['iot_device_connectivity'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_connectivity_info(
    thing_name: str = Path(..., alias='ThingName'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: GreengrassThingsThingNameConnectivityInfoPutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/greengrass/things/{ThingName}/runtimeconfig',
    description=""" Get the runtime configuration of a thing. """,
    tags=['iot_device_connectivity', 'service_role_configuration'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def get_thing_runtime_configuration(
    thing_name: str = Path(..., alias='ThingName'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/greengrass/things/{ThingName}/runtimeconfig',
    description=""" Updates the runtime configuration of a thing. """,
    tags=['iot_device_connectivity'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def update_thing_runtime_configuration(
    thing_name: str = Path(..., alias='ThingName'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: GreengrassThingsThingNameRuntimeconfigPutRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/greengrass/updates',
    description=""" Creates a software update for a core or group of cores (specified as an IoT thing group.) Use this to update the OTA Agent as well as the Greengrass core software. It makes use of the IoT Jobs feature which provides additional commands to manage a Greengrass core software update job. """,
    tags=['iot_device_connectivity'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def create_software_update_job(
    x__amzn__client__token: Optional[str] = Header(None, alias='X-Amzn-Client-Token'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: GreengrassUpdatesPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/tags/{resource-arn}',
    description=""" Retrieves a list of resource tags for a resource arn. """,
    tags=['resource_definition_handling'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def list_tags_for_resource(
    resource_arn: str = Path(..., alias='resource-arn'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/tags/{resource-arn}',
    description=""" Adds tags to a Greengrass resource. Valid resources are 'Group', 'ConnectorDefinition', 'CoreDefinition', 'DeviceDefinition', 'FunctionDefinition', 'LoggerDefinition', 'SubscriptionDefinition', 'ResourceDefinition', and 'BulkDeployment'. """,
    tags=['resource_definition_handling', 'resource_tag_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def tag_resource(
    resource_arn: str = Path(..., alias='resource-arn'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
    body: TagsResourceArnPostRequest = ...,
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/tags/{resource-arn}#tagKeys',
    description=""" Remove resource tags from a Greengrass Resource. """,
    tags=['resource_tag_management'],
    security=[
        APIKeyHeader(name="Authorization"),
    ],
)
def untag_resource(
    resource_arn: str = Path(..., alias='resource-arn'),
    tag_keys: TagKeys = Query(..., alias='tagKeys'),
    x__amz__content__sha256: Optional[str] = Header(None, alias='X-Amz-Content-Sha256'),
    x__amz__date: Optional[str] = Header(None, alias='X-Amz-Date'),
    x__amz__algorithm: Optional[str] = Header(None, alias='X-Amz-Algorithm'),
    x__amz__credential: Optional[str] = Header(None, alias='X-Amz-Credential'),
    x__amz__security__token: Optional[str] = Header(None, alias='X-Amz-Security-Token'),
    x__amz__signature: Optional[str] = Header(None, alias='X-Amz-Signature'),
    x__amz__signed_headers: Optional[str] = Header(None, alias='X-Amz-SignedHeaders'),
):
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
